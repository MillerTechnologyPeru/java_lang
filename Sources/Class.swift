
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:25 GMT 2016 ///

/// class java.lang.Class ///

open class Class: JavaObject, /* java.io.Serializable */ UnclassedProtocol, GenericDeclaration, Type, AnnotatedElement {

    public convenience init?( casting object: JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.lang.Class", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ClassJNIClass: jclass?

    /// private static final int java.lang.Class.ANNOTATION

    /// private static final int java.lang.Class.ENUM

    /// private static final int java.lang.Class.SYNTHETIC

    /// private transient volatile java.lang.reflect.Constructor java.lang.Class.cachedConstructor

    /// private transient volatile java.lang.Class java.lang.Class.newInstanceCallerCache

    /// private transient java.lang.String java.lang.Class.name

    /// private static java.security.ProtectionDomain java.lang.Class.allPermDomain

    /// private static boolean java.lang.Class.useCaches

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.declaredFields

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.publicFields

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.declaredMethods

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.publicMethods

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.declaredConstructors

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.publicConstructors

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.declaredPublicFields

    /// private transient volatile java.lang.ref.SoftReference java.lang.Class.declaredPublicMethods

    /// private transient volatile int java.lang.Class.classRedefinedCount

    /// private transient volatile int java.lang.Class.lastRedefinedCount

    /// private transient sun.reflect.generics.repository.ClassRepository java.lang.Class.genericInfo

    /// private static final long java.lang.Class.serialVersionUID

    /// private static final java.io.ObjectStreamField[] java.lang.Class.serialPersistentFields

    /// private static sun.reflect.ReflectionFactory java.lang.Class.reflectionFactory

    /// private static boolean java.lang.Class.initted

    /// private transient volatile java.lang.Object[] java.lang.Class.enumConstants

    /// private transient volatile java.util.Map java.lang.Class.enumConstantDirectory

    /// private transient java.util.Map java.lang.Class.annotations

    /// private transient java.util.Map java.lang.Class.declaredAnnotations

    /// private sun.reflect.annotation.AnnotationType java.lang.Class.annotationType

    /// private java.lang.Class()

    /// private void java.lang.Class.checkPackageAccess(java.lang.ClassLoader,boolean)

    /// private java.lang.Object java.lang.Class.newInstance0() throws java.lang.InstantiationException,java.lang.IllegalAccessException

    /// public static java.lang.Class java.lang.Class.forName(java.lang.String) throws java.lang.ClassNotFoundException

    private static var forName_MethodID_1: jmethodID?

    open class func forName( arg0: String? ) throws /* java.lang.ClassNotFoundException */ -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Class", classCache: &ClassJNIClass, methodName: "forName", methodSig: "(Ljava/lang/String;)Ljava/lang/Class;", methodCache: &forName_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw ClassNotFoundException( javaObject: throwable )
        }
        return __return != nil ? Class( javaObject: __return ) : nil
    }

    open class func forName( _ _arg0: String? ) throws /* java.lang.ClassNotFoundException */ -> Class! {
        return try forName( arg0: _arg0 )
    }

    /// public static java.lang.Class java.lang.Class.forName(java.lang.String,boolean,java.lang.ClassLoader) throws java.lang.ClassNotFoundException

    private static var forName_MethodID_2: jmethodID?

    open class func forName( arg0: String?, arg1: Bool, arg2: ClassLoader? ) throws /* java.lang.ClassNotFoundException */ -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Class", classCache: &ClassJNIClass, methodName: "forName", methodSig: "(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;", methodCache: &forName_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw ClassNotFoundException( javaObject: throwable )
        }
        return __return != nil ? Class( javaObject: __return ) : nil
    }

    open class func forName( _ _arg0: String?, _ _arg1: Bool, _ _arg2: ClassLoader? ) throws /* java.lang.ClassNotFoundException */ -> Class! {
        return try forName( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// private static native java.lang.Class java.lang.Class.forName0(java.lang.String,boolean,java.lang.ClassLoader) throws java.lang.ClassNotFoundException

    /// public java.lang.String java.lang.Class.toString()

    /// public native boolean java.lang.Class.isAssignableFrom(java.lang.Class)

    private static var isAssignableFrom_MethodID_3: jmethodID?

    open func isAssignableFrom( arg0: Class? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAssignableFrom", methodSig: "(Ljava/lang/Class;)Z", methodCache: &Class.isAssignableFrom_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isAssignableFrom( _ _arg0: Class? ) -> Bool {
        return isAssignableFrom( arg0: _arg0 )
    }

    /// public native boolean java.lang.Class.isInstance(java.lang.Object)

    private static var isInstance_MethodID_4: jmethodID?

    open func isInstance( arg0: JavaObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isInstance", methodSig: "(Ljava/lang/Object;)Z", methodCache: &Class.isInstance_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isInstance( _ _arg0: JavaObject? ) -> Bool {
        return isInstance( arg0: _arg0 )
    }

    /// public native int java.lang.Class.getModifiers()

    private static var getModifiers_MethodID_5: jmethodID?

    open func getModifiers() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getModifiers", methodSig: "()I", methodCache: &Class.getModifiers_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public native boolean java.lang.Class.isInterface()

    private static var isInterface_MethodID_6: jmethodID?

    open func isInterface() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isInterface", methodSig: "()Z", methodCache: &Class.isInterface_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public native boolean java.lang.Class.isArray()

    private static var isArray_MethodID_7: jmethodID?

    open func isArray() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isArray", methodSig: "()Z", methodCache: &Class.isArray_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public native boolean java.lang.Class.isPrimitive()

    private static var isPrimitive_MethodID_8: jmethodID?

    open func isPrimitive() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isPrimitive", methodSig: "()Z", methodCache: &Class.isPrimitive_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public native java.lang.Class java.lang.Class.getSuperclass()

    private static var getSuperclass_MethodID_9: jmethodID?

    open func getSuperclass() -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSuperclass", methodSig: "()Ljava/lang/Class;", methodCache: &Class.getSuperclass_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Class( javaObject: __return ) : nil
    }


    /// public native java.lang.Class java.lang.Class.getComponentType()

    private static var getComponentType_MethodID_10: jmethodID?

    open func getComponentType() -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getComponentType", methodSig: "()Ljava/lang/Class;", methodCache: &Class.getComponentType_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Class( javaObject: __return ) : nil
    }


    /// private static native void java.lang.Class.registerNatives()

    /// public java.lang.String java.lang.Class.getName()

    private static var getName_MethodID_11: jmethodID?

    open func getName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Class.getName_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// java.util.Map java.lang.Class.enumConstantDirectory()

    /// public java.lang.Object java.lang.Class.newInstance() throws java.lang.InstantiationException,java.lang.IllegalAccessException

    private static var newInstance_MethodID_12: jmethodID?

    open func newInstance() throws /* java.lang.InstantiationException, java.lang.IllegalAccessException */ -> JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "newInstance", methodSig: "()Ljava/lang/Object;", methodCache: &Class.newInstance_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw InstantiationException( javaObject: throwable )
        }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }


    /// public boolean java.lang.Class.isAnnotation()

    private static var isAnnotation_MethodID_13: jmethodID?

    open func isAnnotation() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotation", methodSig: "()Z", methodCache: &Class.isAnnotation_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public boolean java.lang.Class.isSynthetic()

    private static var isSynthetic_MethodID_14: jmethodID?

    open func isSynthetic() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSynthetic", methodSig: "()Z", methodCache: &Class.isSynthetic_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// private native java.lang.String java.lang.Class.getName0()

    /// public java.lang.ClassLoader java.lang.Class.getClassLoader()

    private static var getClassLoader_MethodID_15: jmethodID?

    open func getClassLoader() -> ClassLoader! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClassLoader", methodSig: "()Ljava/lang/ClassLoader;", methodCache: &Class.getClassLoader_MethodID_15, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ClassLoader( javaObject: __return ) : nil
    }


    /// native java.lang.ClassLoader java.lang.Class.getClassLoader0()

    /// public java.lang.reflect.TypeVariable[] java.lang.Class.getTypeParameters()

    private static var getTypeParameters_MethodID_16: jmethodID?

    open func getTypeParameters() -> [TypeVariable]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTypeParameters", methodSig: "()[Ljava/lang/reflect/TypeVariable;", methodCache: &Class.getTypeParameters_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: [TypeVariableForward](), from: __return )
    }


    /// public java.lang.reflect.Type java.lang.Class.getGenericSuperclass()

    private static var getGenericSuperclass_MethodID_17: jmethodID?

    open func getGenericSuperclass() -> Type! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericSuperclass", methodSig: "()Ljava/lang/reflect/Type;", methodCache: &Class.getGenericSuperclass_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TypeForward( javaObject: __return ) : nil
    }


    /// public java.lang.Package java.lang.Class.getPackage()

    private static var getPackage_MethodID_18: jmethodID?

    open func getPackage() -> Package! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getPackage", methodSig: "()Ljava/lang/Package;", methodCache: &Class.getPackage_MethodID_18, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Package( javaObject: __return ) : nil
    }


    /// public native java.lang.Class[] java.lang.Class.getInterfaces()

    private static var getInterfaces_MethodID_19: jmethodID?

    open func getInterfaces() -> [Class]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getInterfaces", methodSig: "()[Ljava/lang/Class;", methodCache: &Class.getInterfaces_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Class](), from: __return )
    }


    /// public java.lang.reflect.Type[] java.lang.Class.getGenericInterfaces()

    private static var getGenericInterfaces_MethodID_20: jmethodID?

    open func getGenericInterfaces() -> [Type]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericInterfaces", methodSig: "()[Ljava/lang/reflect/Type;", methodCache: &Class.getGenericInterfaces_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.decode( type: [TypeForward](), from: __return )
    }


    /// public native java.lang.Object[] java.lang.Class.getSigners()

    private static var getSigners_MethodID_21: jmethodID?

    open func getSigners() -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSigners", methodSig: "()[Ljava/lang/Object;", methodCache: &Class.getSigners_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }


    /// native void java.lang.Class.setSigners(java.lang.Object[])

    /// public java.lang.reflect.Method java.lang.Class.getEnclosingMethod()

    private static var getEnclosingMethod_MethodID_22: jmethodID?

    open func getEnclosingMethod() -> Method! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingMethod", methodSig: "()Ljava/lang/reflect/Method;", methodCache: &Class.getEnclosingMethod_MethodID_22, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Method( javaObject: __return ) : nil
    }


    /// private native java.lang.Object[] java.lang.Class.getEnclosingMethod0()

    /// private java.lang.Class$EnclosingMethodInfo java.lang.Class.getEnclosingMethodInfo()

    /// private static java.lang.Class java.lang.Class.toClass(java.lang.reflect.Type)

    /// public java.lang.reflect.Constructor java.lang.Class.getEnclosingConstructor()

    private static var getEnclosingConstructor_MethodID_23: jmethodID?

    open func getEnclosingConstructor() -> Constructor! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingConstructor", methodSig: "()Ljava/lang/reflect/Constructor;", methodCache: &Class.getEnclosingConstructor_MethodID_23, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Constructor( javaObject: __return ) : nil
    }


    /// public java.lang.Class java.lang.Class.getDeclaringClass()

    private static var getDeclaringClass_MethodID_24: jmethodID?

    open func getDeclaringClass() -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaringClass", methodSig: "()Ljava/lang/Class;", methodCache: &Class.getDeclaringClass_MethodID_24, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Class( javaObject: __return ) : nil
    }


    /// private native java.lang.Class java.lang.Class.getDeclaringClass0()

    /// public java.lang.Class java.lang.Class.getEnclosingClass()

    private static var getEnclosingClass_MethodID_25: jmethodID?

    open func getEnclosingClass() -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnclosingClass", methodSig: "()Ljava/lang/Class;", methodCache: &Class.getEnclosingClass_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Class( javaObject: __return ) : nil
    }


    /// public java.lang.String java.lang.Class.getSimpleName()

    private static var getSimpleName_MethodID_26: jmethodID?

    open func getSimpleName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSimpleName", methodSig: "()Ljava/lang/String;", methodCache: &Class.getSimpleName_MethodID_26, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// private static boolean java.lang.Class.isAsciiDigit(char)

    /// public java.lang.String java.lang.Class.getCanonicalName()

    private static var getCanonicalName_MethodID_27: jmethodID?

    open func getCanonicalName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getCanonicalName", methodSig: "()Ljava/lang/String;", methodCache: &Class.getCanonicalName_MethodID_27, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public boolean java.lang.Class.isAnonymousClass()

    private static var isAnonymousClass_MethodID_28: jmethodID?

    open func isAnonymousClass() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnonymousClass", methodSig: "()Z", methodCache: &Class.isAnonymousClass_MethodID_28, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public boolean java.lang.Class.isLocalClass()

    private static var isLocalClass_MethodID_29: jmethodID?

    open func isLocalClass() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isLocalClass", methodSig: "()Z", methodCache: &Class.isLocalClass_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public boolean java.lang.Class.isMemberClass()

    private static var isMemberClass_MethodID_30: jmethodID?

    open func isMemberClass() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isMemberClass", methodSig: "()Z", methodCache: &Class.isMemberClass_MethodID_30, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// private java.lang.String java.lang.Class.getSimpleBinaryName()

    /// private boolean java.lang.Class.isLocalOrAnonymousClass()

    /// public java.lang.Class[] java.lang.Class.getClasses()

    private static var getClasses_MethodID_31: jmethodID?

    open func getClasses() -> [Class]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getClasses", methodSig: "()[Ljava/lang/Class;", methodCache: &Class.getClasses_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Class](), from: __return )
    }


    /// public java.lang.reflect.Field[] java.lang.Class.getFields() throws java.lang.SecurityException

    private static var getFields_MethodID_32: jmethodID?

    open func getFields() throws /* java.lang.SecurityException */ -> [Field]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFields", methodSig: "()[Ljava/lang/reflect/Field;", methodCache: &Class.getFields_MethodID_32, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Field](), from: __return )
    }


    /// public java.lang.reflect.Method[] java.lang.Class.getMethods() throws java.lang.SecurityException

    private static var getMethods_MethodID_33: jmethodID?

    open func getMethods() throws /* java.lang.SecurityException */ -> [Method]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMethods", methodSig: "()[Ljava/lang/reflect/Method;", methodCache: &Class.getMethods_MethodID_33, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Method](), from: __return )
    }


    /// public java.lang.reflect.Constructor[] java.lang.Class.getConstructors() throws java.lang.SecurityException

    private static var getConstructors_MethodID_34: jmethodID?

    open func getConstructors() throws /* java.lang.SecurityException */ -> [Constructor]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConstructors", methodSig: "()[Ljava/lang/reflect/Constructor;", methodCache: &Class.getConstructors_MethodID_34, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Constructor](), from: __return )
    }


    /// public java.lang.reflect.Field java.lang.Class.getField(java.lang.String) throws java.lang.NoSuchFieldException,java.lang.SecurityException

    private static var getField_MethodID_35: jmethodID?

    open func getField( arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> Field! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getField", methodSig: "(Ljava/lang/String;)Ljava/lang/reflect/Field;", methodCache: &Class.getField_MethodID_35, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchFieldException( javaObject: throwable )
        }
        return __return != nil ? Field( javaObject: __return ) : nil
    }

    open func getField( _ _arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> Field! {
        return try getField( arg0: _arg0 )
    }

    /// public java.lang.reflect.Method java.lang.Class.getMethod(java.lang.String,java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getMethod_MethodID_36: jmethodID?

    open func getMethod( arg0: String?, arg1: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Method! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getMethod", methodSig: "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;", methodCache: &Class.getMethod_MethodID_36, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchMethodException( javaObject: throwable )
        }
        return __return != nil ? Method( javaObject: __return ) : nil
    }

    open func getMethod( _ _arg0: String?, _ _arg1: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Method! {
        return try getMethod( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.lang.reflect.Constructor java.lang.Class.getConstructor(java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getConstructor_MethodID_37: jmethodID?

    open func getConstructor( arg0: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Constructor! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getConstructor", methodSig: "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;", methodCache: &Class.getConstructor_MethodID_37, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchMethodException( javaObject: throwable )
        }
        return __return != nil ? Constructor( javaObject: __return ) : nil
    }

    open func getConstructor( _ _arg0: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Constructor! {
        return try getConstructor( arg0: _arg0 )
    }

    /// public java.lang.Class[] java.lang.Class.getDeclaredClasses() throws java.lang.SecurityException

    private static var getDeclaredClasses_MethodID_38: jmethodID?

    open func getDeclaredClasses() throws /* java.lang.SecurityException */ -> [Class]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredClasses", methodSig: "()[Ljava/lang/Class;", methodCache: &Class.getDeclaredClasses_MethodID_38, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Class](), from: __return )
    }


    /// public java.lang.reflect.Field[] java.lang.Class.getDeclaredFields() throws java.lang.SecurityException

    private static var getDeclaredFields_MethodID_39: jmethodID?

    open func getDeclaredFields() throws /* java.lang.SecurityException */ -> [Field]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredFields", methodSig: "()[Ljava/lang/reflect/Field;", methodCache: &Class.getDeclaredFields_MethodID_39, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Field](), from: __return )
    }


    /// public java.lang.reflect.Method[] java.lang.Class.getDeclaredMethods() throws java.lang.SecurityException

    private static var getDeclaredMethods_MethodID_40: jmethodID?

    open func getDeclaredMethods() throws /* java.lang.SecurityException */ -> [Method]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredMethods", methodSig: "()[Ljava/lang/reflect/Method;", methodCache: &Class.getDeclaredMethods_MethodID_40, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Method](), from: __return )
    }


    /// public java.lang.reflect.Constructor[] java.lang.Class.getDeclaredConstructors() throws java.lang.SecurityException

    private static var getDeclaredConstructors_MethodID_41: jmethodID?

    open func getDeclaredConstructors() throws /* java.lang.SecurityException */ -> [Constructor]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredConstructors", methodSig: "()[Ljava/lang/reflect/Constructor;", methodCache: &Class.getDeclaredConstructors_MethodID_41, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw JavaSecurityException( javaObject: throwable )
        }
        return JNIType.decode( type: [Constructor](), from: __return )
    }


    /// public java.lang.reflect.Field java.lang.Class.getDeclaredField(java.lang.String) throws java.lang.NoSuchFieldException,java.lang.SecurityException

    private static var getDeclaredField_MethodID_42: jmethodID?

    open func getDeclaredField( arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> Field! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredField", methodSig: "(Ljava/lang/String;)Ljava/lang/reflect/Field;", methodCache: &Class.getDeclaredField_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchFieldException( javaObject: throwable )
        }
        return __return != nil ? Field( javaObject: __return ) : nil
    }

    open func getDeclaredField( _ _arg0: String? ) throws /* java.lang.NoSuchFieldException, java.lang.SecurityException */ -> Field! {
        return try getDeclaredField( arg0: _arg0 )
    }

    /// public java.lang.reflect.Method java.lang.Class.getDeclaredMethod(java.lang.String,java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getDeclaredMethod_MethodID_43: jmethodID?

    open func getDeclaredMethod( arg0: String?, arg1: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Method! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredMethod", methodSig: "(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;", methodCache: &Class.getDeclaredMethod_MethodID_43, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchMethodException( javaObject: throwable )
        }
        return __return != nil ? Method( javaObject: __return ) : nil
    }

    open func getDeclaredMethod( _ _arg0: String?, _ _arg1: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Method! {
        return try getDeclaredMethod( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.lang.reflect.Constructor java.lang.Class.getDeclaredConstructor(java.lang.Class[]) throws java.lang.NoSuchMethodException,java.lang.SecurityException

    private static var getDeclaredConstructor_MethodID_44: jmethodID?

    open func getDeclaredConstructor( arg0: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Constructor! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredConstructor", methodSig: "([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;", methodCache: &Class.getDeclaredConstructor_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NoSuchMethodException( javaObject: throwable )
        }
        return __return != nil ? Constructor( javaObject: __return ) : nil
    }

    open func getDeclaredConstructor( _ _arg0: [Class]? ) throws /* java.lang.NoSuchMethodException, java.lang.SecurityException */ -> Constructor! {
        return try getDeclaredConstructor( arg0: _arg0 )
    }

    /// public java.io.InputStream java.lang.Class.getResourceAsStream(java.lang.String)

    private static var getResourceAsStream_MethodID_45: jmethodID?

    open func getResourceAsStream( arg0: String? ) -> /* java.io.InputStream */ UnclassedObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceAsStream", methodSig: "(Ljava/lang/String;)Ljava/io/InputStream;", methodCache: &Class.getResourceAsStream_MethodID_45, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* java.io.InputStream */ UnclassedObject( javaObject: __return ) : nil
    }

    open func getResourceAsStream( _ _arg0: String? ) -> /* java.io.InputStream */ UnclassedObject! {
        return getResourceAsStream( arg0: _arg0 )
    }

    /// public java.net.URL java.lang.Class.getResource(java.lang.String)

    private static var getResource_MethodID_46: jmethodID?

    open func getResource( arg0: String? ) -> /* java.net.URL */ UnclassedObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResource", methodSig: "(Ljava/lang/String;)Ljava/net/URL;", methodCache: &Class.getResource_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* java.net.URL */ UnclassedObject( javaObject: __return ) : nil
    }

    open func getResource( _ _arg0: String? ) -> /* java.net.URL */ UnclassedObject! {
        return getResource( arg0: _arg0 )
    }

    /// public java.security.ProtectionDomain java.lang.Class.getProtectionDomain()

    private static var getProtectionDomain_MethodID_47: jmethodID?

    open func getProtectionDomain() -> /* java.security.ProtectionDomain */ UnclassedObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getProtectionDomain", methodSig: "()Ljava/security/ProtectionDomain;", methodCache: &Class.getProtectionDomain_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? /* java.security.ProtectionDomain */ UnclassedObject( javaObject: __return ) : nil
    }


    /// private native java.security.ProtectionDomain java.lang.Class.getProtectionDomain0()

    /// native void java.lang.Class.setProtectionDomain0(java.security.ProtectionDomain)

    /// static native java.lang.Class java.lang.Class.getPrimitiveClass(java.lang.String)

    /// private void java.lang.Class.checkMemberAccess(int,java.lang.ClassLoader,boolean)

    /// private java.lang.String java.lang.Class.resolveName(java.lang.String)

    /// private void java.lang.Class.clearCachesOnClassRedefinition()

    /// private native java.lang.String java.lang.Class.getGenericSignature()

    /// private sun.reflect.generics.factory.GenericsFactory java.lang.Class.getFactory()

    /// private sun.reflect.generics.repository.ClassRepository java.lang.Class.getGenericInfo()

    /// private native byte[] java.lang.Class.getRawAnnotations()

    /// native sun.reflect.ConstantPool java.lang.Class.getConstantPool()

    /// private java.lang.reflect.Field[] java.lang.Class.privateGetDeclaredFields(boolean)

    /// private java.lang.reflect.Field[] java.lang.Class.privateGetPublicFields(java.util.Set)

    /// private static void java.lang.Class.addAll(java.util.Collection,java.lang.reflect.Field[])

    /// private java.lang.reflect.Constructor[] java.lang.Class.privateGetDeclaredConstructors(boolean)

    /// private java.lang.reflect.Method[] java.lang.Class.privateGetDeclaredMethods(boolean)

    /// private java.lang.reflect.Method[] java.lang.Class.privateGetPublicMethods()

    /// private java.lang.reflect.Field java.lang.Class.searchFields(java.lang.reflect.Field[],java.lang.String)

    /// private java.lang.reflect.Field java.lang.Class.getField0(java.lang.String) throws java.lang.NoSuchFieldException

    /// private static java.lang.reflect.Method java.lang.Class.searchMethods(java.lang.reflect.Method[],java.lang.String,java.lang.Class[])

    /// private java.lang.reflect.Method java.lang.Class.getMethod0(java.lang.String,java.lang.Class[])

    /// private java.lang.reflect.Constructor java.lang.Class.getConstructor0(java.lang.Class[],int) throws java.lang.NoSuchMethodException

    /// private static boolean java.lang.Class.arrayContentsEq(java.lang.Object[],java.lang.Object[])

    /// private static java.lang.reflect.Field[] java.lang.Class.copyFields(java.lang.reflect.Field[])

    /// private static java.lang.reflect.Method[] java.lang.Class.copyMethods(java.lang.reflect.Method[])

    /// private static java.lang.reflect.Constructor[] java.lang.Class.copyConstructors(java.lang.reflect.Constructor[])

    /// private native java.lang.reflect.Field[] java.lang.Class.getDeclaredFields0(boolean)

    /// private native java.lang.reflect.Method[] java.lang.Class.getDeclaredMethods0(boolean)

    /// private native java.lang.reflect.Constructor[] java.lang.Class.getDeclaredConstructors0(boolean)

    /// private native java.lang.Class[] java.lang.Class.getDeclaredClasses0()

    /// private static java.lang.String java.lang.Class.argumentTypesToString(java.lang.Class[])

    /// public boolean java.lang.Class.desiredAssertionStatus()

    private static var desiredAssertionStatus_MethodID_48: jmethodID?

    open func desiredAssertionStatus() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "desiredAssertionStatus", methodSig: "()Z", methodCache: &Class.desiredAssertionStatus_MethodID_48, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// private static native boolean java.lang.Class.desiredAssertionStatus0(java.lang.Class)

    /// public boolean java.lang.Class.isEnum()

    private static var isEnum_MethodID_49: jmethodID?

    open func isEnum() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isEnum", methodSig: "()Z", methodCache: &Class.isEnum_MethodID_49, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// private static sun.reflect.ReflectionFactory java.lang.Class.getReflectionFactory()

    /// private static void java.lang.Class.checkInitted()

    /// public java.lang.Object[] java.lang.Class.getEnumConstants()

    private static var getEnumConstants_MethodID_50: jmethodID?

    open func getEnumConstants() -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEnumConstants", methodSig: "()[Ljava/lang/Object;", methodCache: &Class.getEnumConstants_MethodID_50, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }


    /// java.lang.Object[] java.lang.Class.getEnumConstantsShared()

    /// public java.lang.Object java.lang.Class.cast(java.lang.Object)

    private static var cast_MethodID_51: jmethodID?

    open func cast( arg0: JavaObject? ) -> JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "cast", methodSig: "(Ljava/lang/Object;)Ljava/lang/Object;", methodCache: &Class.cast_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }

    open func cast( _ _arg0: JavaObject? ) -> JavaObject! {
        return cast( arg0: _arg0 )
    }

    /// public java.lang.Class java.lang.Class.asSubclass(java.lang.Class)

    private static var asSubclass_MethodID_52: jmethodID?

    open func asSubclass( arg0: Class? ) -> Class! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "asSubclass", methodSig: "(Ljava/lang/Class;)Ljava/lang/Class;", methodCache: &Class.asSubclass_MethodID_52, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Class( javaObject: __return ) : nil
    }

    open func asSubclass( _ _arg0: Class? ) -> Class! {
        return asSubclass( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation java.lang.Class.getAnnotation(java.lang.Class)

    private static var getAnnotation_MethodID_53: jmethodID?

    open func getAnnotation( arg0: Class? ) -> Annotation! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &Class.getAnnotation_MethodID_53, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotationForward( javaObject: __return ) : nil
    }

    open func getAnnotation( _ _arg0: Class? ) -> Annotation! {
        return getAnnotation( arg0: _arg0 )
    }

    /// public boolean java.lang.Class.isAnnotationPresent(java.lang.Class)

    private static var isAnnotationPresent_MethodID_54: jmethodID?

    open func isAnnotationPresent( arg0: Class? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotationPresent", methodSig: "(Ljava/lang/Class;)Z", methodCache: &Class.isAnnotationPresent_MethodID_54, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isAnnotationPresent( _ _arg0: Class? ) -> Bool {
        return isAnnotationPresent( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.Class.getAnnotations()

    private static var getAnnotations_MethodID_55: jmethodID?

    open func getAnnotations() -> [Annotation]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Class.getAnnotations_MethodID_55, args: &__args, locals: &__locals )
        return JNIType.decode( type: [AnnotationForward](), from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Class.getDeclaredAnnotations()

    private static var getDeclaredAnnotations_MethodID_56: jmethodID?

    open func getDeclaredAnnotations() -> [Annotation]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Class.getDeclaredAnnotations_MethodID_56, args: &__args, locals: &__locals )
        return JNIType.decode( type: [AnnotationForward](), from: __return )
    }


    /// private synchronized void java.lang.Class.initAnnotationsIfNecessary()

    /// void java.lang.Class.setAnnotationType(sun.reflect.annotation.AnnotationType)

    /// sun.reflect.annotation.AnnotationType java.lang.Class.getAnnotationType()

    /// static boolean java.lang.Class.access$100(java.lang.Object[],java.lang.Object[])

    /// static boolean java.lang.Class.access$202(boolean)

    /// static boolean java.lang.Class.access$302(boolean)

}
