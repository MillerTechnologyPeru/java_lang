
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:09 GMT 2016 ///

/// class java.lang.Package ///

open class Package: JavaObject, AnnotatedElement {

    public convenience init?( casting object: JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.lang.Package", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var PackageJNIClass: jclass?

    /// private static java.util.Map java.lang.Package.pkgs

    /// private static java.util.Map java.lang.Package.urls

    /// private static java.util.Map java.lang.Package.mans

    /// private final java.lang.String java.lang.Package.pkgName

    /// private final java.lang.String java.lang.Package.specTitle

    /// private final java.lang.String java.lang.Package.specVersion

    /// private final java.lang.String java.lang.Package.specVendor

    /// private final java.lang.String java.lang.Package.implTitle

    /// private final java.lang.String java.lang.Package.implVersion

    /// private final java.lang.String java.lang.Package.implVendor

    /// private final java.net.URL java.lang.Package.sealBase

    /// private final transient java.lang.ClassLoader java.lang.Package.loader

    /// private transient java.lang.Class java.lang.Package.packageInfo

    /// java.lang.Package(java.lang.String,java.util.jar.Manifest,java.net.URL,java.lang.ClassLoader,java.lang.Package$1)

    /// private java.lang.Package(java.lang.String,java.util.jar.Manifest,java.net.URL,java.lang.ClassLoader)

    /// java.lang.Package(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.net.URL,java.lang.ClassLoader)

    /// public java.lang.String java.lang.Package.toString()

    /// public int java.lang.Package.hashCode()

    /// public java.lang.String java.lang.Package.getName()

    private static var getName_MethodID_1: jmethodID?

    open func getName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Package.getName_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public static java.lang.Package java.lang.Package.getPackage(java.lang.String)

    private static var getPackage_MethodID_2: jmethodID?

    open class func getPackage( arg0: String? ) -> Package! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Package", classCache: &PackageJNIClass, methodName: "getPackage", methodSig: "(Ljava/lang/String;)Ljava/lang/Package;", methodCache: &getPackage_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Package( javaObject: __return ) : nil
    }

    open class func getPackage( _ _arg0: String? ) -> Package! {
        return getPackage( arg0: _arg0 )
    }

    /// static java.lang.Package java.lang.Package.getPackage(java.lang.Class)

    /// public java.lang.annotation.Annotation java.lang.Package.getAnnotation(java.lang.Class)

    private static var getAnnotation_MethodID_3: jmethodID?

    open func getAnnotation( arg0: Class? ) -> Annotation! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &Package.getAnnotation_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotationForward( javaObject: __return ) : nil
    }

    open func getAnnotation( _ _arg0: Class? ) -> Annotation! {
        return getAnnotation( arg0: _arg0 )
    }

    /// public boolean java.lang.Package.isAnnotationPresent(java.lang.Class)

    private static var isAnnotationPresent_MethodID_4: jmethodID?

    open func isAnnotationPresent( arg0: Class? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isAnnotationPresent", methodSig: "(Ljava/lang/Class;)Z", methodCache: &Package.isAnnotationPresent_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isAnnotationPresent( _ _arg0: Class? ) -> Bool {
        return isAnnotationPresent( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.Package.getAnnotations()

    private static var getAnnotations_MethodID_5: jmethodID?

    open func getAnnotations() -> [Annotation]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Package.getAnnotations_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: [AnnotationForward](), from: __return )
    }


    /// public java.lang.annotation.Annotation[] java.lang.Package.getDeclaredAnnotations()

    private static var getDeclaredAnnotations_MethodID_6: jmethodID?

    open func getDeclaredAnnotations() -> [Annotation]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaredAnnotations", methodSig: "()[Ljava/lang/annotation/Annotation;", methodCache: &Package.getDeclaredAnnotations_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: [AnnotationForward](), from: __return )
    }


    /// static java.util.jar.Manifest java.lang.Package.access$100(java.lang.String)

    /// public static java.lang.Package[] java.lang.Package.getPackages()

    private static var getPackages_MethodID_7: jmethodID?

    open class func getPackages() -> [Package]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/Package", classCache: &PackageJNIClass, methodName: "getPackages", methodSig: "()[Ljava/lang/Package;", methodCache: &getPackages_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Package](), from: __return )
    }


    /// static java.util.Map java.lang.Package.access$000()

    /// static java.lang.Package java.lang.Package.getSystemPackage(java.lang.String)

    /// static java.lang.Package[] java.lang.Package.getSystemPackages()

    /// static java.util.Map java.lang.Package.access$200()

    /// static java.util.Map java.lang.Package.access$400()

    /// public boolean java.lang.Package.isSealed()

    private static var isSealed_MethodID_8: jmethodID?

    open func isSealed() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSealed", methodSig: "()Z", methodCache: &Package.isSealed_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public boolean java.lang.Package.isSealed(java.net.URL)

    private static var isSealed_MethodID_9: jmethodID?

    open func isSealed( arg0: /* java.net.URL */ UnclassedObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSealed", methodSig: "(Ljava/net/URL;)Z", methodCache: &Package.isSealed_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isSealed( _ _arg0: /* java.net.URL */ UnclassedObject? ) -> Bool {
        return isSealed( arg0: _arg0 )
    }

    /// public java.lang.String java.lang.Package.getSpecificationTitle()

    private static var getSpecificationTitle_MethodID_10: jmethodID?

    open func getSpecificationTitle() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationTitle", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationTitle_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public java.lang.String java.lang.Package.getSpecificationVersion()

    private static var getSpecificationVersion_MethodID_11: jmethodID?

    open func getSpecificationVersion() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationVersion", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationVersion_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public java.lang.String java.lang.Package.getSpecificationVendor()

    private static var getSpecificationVendor_MethodID_12: jmethodID?

    open func getSpecificationVendor() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSpecificationVendor", methodSig: "()Ljava/lang/String;", methodCache: &Package.getSpecificationVendor_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public java.lang.String java.lang.Package.getImplementationTitle()

    private static var getImplementationTitle_MethodID_13: jmethodID?

    open func getImplementationTitle() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationTitle", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationTitle_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public java.lang.String java.lang.Package.getImplementationVersion()

    private static var getImplementationVersion_MethodID_14: jmethodID?

    open func getImplementationVersion() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationVersion", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationVersion_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public java.lang.String java.lang.Package.getImplementationVendor()

    private static var getImplementationVendor_MethodID_15: jmethodID?

    open func getImplementationVendor() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getImplementationVendor", methodSig: "()Ljava/lang/String;", methodCache: &Package.getImplementationVendor_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public boolean java.lang.Package.isCompatibleWith(java.lang.String) throws java.lang.NumberFormatException

    private static var isCompatibleWith_MethodID_16: jmethodID?

    open func isCompatibleWith( arg0: String? ) throws /* java.lang.NumberFormatException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isCompatibleWith", methodSig: "(Ljava/lang/String;)Z", methodCache: &Package.isCompatibleWith_MethodID_16, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw NumberFormatException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isCompatibleWith( _ _arg0: String? ) throws /* java.lang.NumberFormatException */ -> Bool {
        return try isCompatibleWith( arg0: _arg0 )
    }

    /// private java.lang.Class java.lang.Package.getPackageInfo()

    /// private static java.lang.Package java.lang.Package.defineSystemPackage(java.lang.String,java.lang.String)

    /// private static java.util.jar.Manifest java.lang.Package.loadManifest(java.lang.String)

    /// private static native java.lang.String java.lang.Package.getSystemPackage0(java.lang.String)

    /// private static native java.lang.String[] java.lang.Package.getSystemPackages0()

}
