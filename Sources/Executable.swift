
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.reflect.Executable ///

open class Executable: AccessibleObject, Member, GenericDeclaration {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ExecutableJNIClass: jclass?

    /// private transient volatile boolean java.lang.reflect.Executable.hasRealParameterData

    /// private transient volatile java.lang.reflect.Parameter[] java.lang.reflect.Executable.parameters

    /// private transient java.util.Map java.lang.reflect.Executable.declaredAnnotations

    /// private static final java.security.Permission java.lang.reflect.AccessibleObject.ACCESS_PERMISSION

    /// boolean java.lang.reflect.AccessibleObject.override

    /// static final sun.reflect.ReflectionFactory java.lang.reflect.AccessibleObject.reflectionFactory

    /// volatile java.lang.Object java.lang.reflect.AccessibleObject.securityCheckCache

    /// public static final int java.lang.reflect.Member.PUBLIC

    private static var PUBLIC_FieldID: jfieldID?

    open static var PUBLIC: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "PUBLIC", fieldType: "I", fieldCache: &PUBLIC_FieldID, className: "java/lang/reflect/Executable", classCache: &ExecutableJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// public static final int java.lang.reflect.Member.DECLARED

    private static var DECLARED_FieldID: jfieldID?

    open static var DECLARED: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "DECLARED", fieldType: "I", fieldCache: &DECLARED_FieldID, className: "java/lang/reflect/Executable", classCache: &ExecutableJNIClass )
            return JNIType.toSwift( type: Int(), from: __value )
        }
    }

    /// java.lang.reflect.Executable()

    /// public abstract int java.lang.reflect.Executable.getModifiers()

    private static var getModifiers_MethodID_1: jmethodID?

    open func getModifiers() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getModifiers", methodSig: "()I", methodCache: &Executable.getModifiers_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract java.lang.String java.lang.reflect.Executable.getName()

    private static var getName_MethodID_2: jmethodID?

    open func getName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Executable.getName_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: String(), from: __return )
    }


    /// public abstract java.lang.String java.lang.reflect.Executable.toGenericString()

    private static var toGenericString_MethodID_3: jmethodID?

    open func toGenericString() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "toGenericString", methodSig: "()Ljava/lang/String;", methodCache: &Executable.toGenericString_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: String(), from: __return )
    }


    /// public boolean java.lang.reflect.Executable.isSynthetic()

    private static var isSynthetic_MethodID_4: jmethodID?

    open func isSynthetic() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSynthetic", methodSig: "()Z", methodCache: &Executable.isSynthetic_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public abstract java.lang.reflect.TypeVariable[] java.lang.reflect.Executable.getTypeParameters()

    private static var getTypeParameters_MethodID_5: jmethodID?

    open func getTypeParameters() -> [TypeVariable]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTypeParameters", methodSig: "()[Ljava/lang/reflect/TypeVariable;", methodCache: &Executable.getTypeParameters_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [TypeVariableForward](), from: __return )
    }


    /// public abstract java.lang.Class java.lang.reflect.Executable.getDeclaringClass()

    private static var getDeclaringClass_MethodID_6: jmethodID?

    open func getDeclaringClass() -> java_swift.JavaClass! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getDeclaringClass", methodSig: "()Ljava/lang/Class;", methodCache: &Executable.getDeclaringClass_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_swift.JavaClass( javaObject: __return ) : nil
    }


    /// abstract sun.reflect.generics.repository.ConstructorRepository java.lang.reflect.Executable.getGenericInfo()

    /// public java.lang.annotation.Annotation java.lang.reflect.Executable.getAnnotation(java.lang.Class)

    private static var getAnnotation_MethodID_7: jmethodID?

    override open func getAnnotation( arg0: java_swift.JavaClass? ) -> Annotation! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotation", methodSig: "(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;", methodCache: &Executable.getAnnotation_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotationForward( javaObject: __return ) : nil
    }

    override open func getAnnotation( _ _arg0: java_swift.JavaClass? ) -> Annotation! {
        return getAnnotation( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.reflect.Executable.getAnnotationsByType(java.lang.Class)

    private static var getAnnotationsByType_MethodID_8: jmethodID?

    override open func getAnnotationsByType( arg0: java_swift.JavaClass? ) -> [Annotation]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotationsByType", methodSig: "(Ljava/lang/Class;)[Ljava/lang/annotation/Annotation;", methodCache: &Executable.getAnnotationsByType_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotationForward](), from: __return )
    }

    override open func getAnnotationsByType( _ _arg0: java_swift.JavaClass? ) -> [Annotation]! {
        return getAnnotationsByType( arg0: _arg0 )
    }

    /// public java.lang.annotation.Annotation[] java.lang.reflect.Executable.getDeclaredAnnotations()

    /// public abstract java.lang.Class[] java.lang.reflect.Executable.getParameterTypes()

    private static var getParameterTypes_MethodID_9: jmethodID?

    open func getParameterTypes() -> [JavaClass]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParameterTypes", methodSig: "()[Ljava/lang/Class;", methodCache: &Executable.getParameterTypes_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaClass](), from: __return )
    }


    /// private synchronized java.util.Map java.lang.reflect.Executable.declaredAnnotations()

    /// native byte[] java.lang.reflect.Executable.getTypeAnnotationBytes0()

    /// public boolean java.lang.reflect.Executable.isVarArgs()

    private static var isVarArgs_MethodID_10: jmethodID?

    open func isVarArgs() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isVarArgs", methodSig: "()Z", methodCache: &Executable.isVarArgs_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// boolean java.lang.reflect.Executable.hasRealParameterData()

    /// java.lang.reflect.Type[] java.lang.reflect.Executable.getAllGenericParameterTypes()

    /// public java.lang.reflect.AnnotatedType[] java.lang.reflect.Executable.getAnnotatedParameterTypes()

    private static var getAnnotatedParameterTypes_MethodID_11: jmethodID?

    open func getAnnotatedParameterTypes() -> [AnnotatedType]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedParameterTypes", methodSig: "()[Ljava/lang/reflect/AnnotatedType;", methodCache: &Executable.getAnnotatedParameterTypes_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotatedTypeForward](), from: __return )
    }


    /// public int java.lang.reflect.Executable.getParameterCount()

    private static var getParameterCount_MethodID_12: jmethodID?

    open func getParameterCount() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getParameterCount", methodSig: "()I", methodCache: &Executable.getParameterCount_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }


    /// public abstract java.lang.annotation.Annotation[][] java.lang.reflect.Executable.getParameterAnnotations()

    private static var getParameterAnnotations_MethodID_13: jmethodID?

    open func getParameterAnnotations() -> [[Annotation]]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParameterAnnotations", methodSig: "()[[Ljava/lang/annotation/Annotation;", methodCache: &Executable.getParameterAnnotations_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [[AnnotationForward]](), from: __return )
    }


    /// abstract java.lang.reflect.Executable java.lang.reflect.Executable.getRoot()

    /// abstract boolean java.lang.reflect.Executable.hasGenericInformation()

    /// abstract byte[] java.lang.reflect.Executable.getAnnotationBytes()

    /// public java.lang.reflect.Type[] java.lang.reflect.Executable.getGenericParameterTypes()

    private static var getGenericParameterTypes_MethodID_14: jmethodID?

    open func getGenericParameterTypes() -> [Type]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericParameterTypes", methodSig: "()[Ljava/lang/reflect/Type;", methodCache: &Executable.getGenericParameterTypes_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [TypeForward](), from: __return )
    }


    /// public abstract java.lang.Class[] java.lang.reflect.Executable.getExceptionTypes()

    private static var getExceptionTypes_MethodID_15: jmethodID?

    open func getExceptionTypes() -> [JavaClass]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getExceptionTypes", methodSig: "()[Ljava/lang/Class;", methodCache: &Executable.getExceptionTypes_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [JavaClass](), from: __return )
    }


    /// public java.lang.reflect.Type[] java.lang.reflect.Executable.getGenericExceptionTypes()

    private static var getGenericExceptionTypes_MethodID_16: jmethodID?

    open func getGenericExceptionTypes() -> [Type]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getGenericExceptionTypes", methodSig: "()[Ljava/lang/reflect/Type;", methodCache: &Executable.getGenericExceptionTypes_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [TypeForward](), from: __return )
    }


    /// abstract void java.lang.reflect.Executable.specificToStringHeader(java.lang.StringBuilder)

    /// abstract void java.lang.reflect.Executable.specificToGenericStringHeader(java.lang.StringBuilder)

    /// public abstract java.lang.reflect.AnnotatedType java.lang.reflect.Executable.getAnnotatedReturnType()

    private static var getAnnotatedReturnType_MethodID_17: jmethodID?

    open func getAnnotatedReturnType() -> AnnotatedType! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedReturnType", methodSig: "()Ljava/lang/reflect/AnnotatedType;", methodCache: &Executable.getAnnotatedReturnType_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotatedTypeForward( javaObject: __return ) : nil
    }


    /// abstract void java.lang.reflect.Executable.handleParameterNumberMismatch(int,int)

    /// boolean java.lang.reflect.Executable.equalParamTypes(java.lang.Class[],java.lang.Class[])

    /// java.lang.String java.lang.reflect.Executable.sharedToString(int,boolean,java.lang.Class[],java.lang.Class[])

    /// java.lang.String java.lang.reflect.Executable.sharedToGenericString(int,boolean)

    /// java.lang.annotation.Annotation[][] java.lang.reflect.Executable.sharedGetParameterAnnotations(java.lang.Class[],byte[])

    /// java.lang.reflect.AnnotatedType java.lang.reflect.Executable.getAnnotatedReturnType0(java.lang.reflect.Type)

    /// java.lang.annotation.Annotation[][] java.lang.reflect.Executable.parseParameterAnnotations(byte[])

    /// void java.lang.reflect.Executable.separateWithCommas(java.lang.Class[],java.lang.StringBuilder)

    /// void java.lang.reflect.Executable.printModifiersIfNonzero(java.lang.StringBuilder,int,boolean)

    /// public java.lang.reflect.Parameter[] java.lang.reflect.Executable.getParameters()

    private static var getParameters_MethodID_18: jmethodID?

    open func getParameters() -> [Parameter]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParameters", methodSig: "()[Ljava/lang/reflect/Parameter;", methodCache: &Executable.getParameters_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [Parameter](), from: __return )
    }


    /// private java.lang.reflect.Parameter[] java.lang.reflect.Executable.synthesizeAllParams()

    /// private void java.lang.reflect.Executable.verifyParameters(java.lang.reflect.Parameter[])

    /// private java.lang.reflect.Parameter[] java.lang.reflect.Executable.privateGetParameters()

    /// private native java.lang.reflect.Parameter[] java.lang.reflect.Executable.getParameters0()

    /// byte[] java.lang.reflect.Executable.getTypeAnnotationBytes()

    /// public java.lang.reflect.AnnotatedType java.lang.reflect.Executable.getAnnotatedReceiverType()

    private static var getAnnotatedReceiverType_MethodID_19: jmethodID?

    open func getAnnotatedReceiverType() -> AnnotatedType! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedReceiverType", methodSig: "()Ljava/lang/reflect/AnnotatedType;", methodCache: &Executable.getAnnotatedReceiverType_MethodID_19, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? AnnotatedTypeForward( javaObject: __return ) : nil
    }


    /// public java.lang.reflect.AnnotatedType[] java.lang.reflect.Executable.getAnnotatedExceptionTypes()

    private static var getAnnotatedExceptionTypes_MethodID_20: jmethodID?

    open func getAnnotatedExceptionTypes() -> [AnnotatedType]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAnnotatedExceptionTypes", methodSig: "()[Ljava/lang/reflect/AnnotatedType;", methodCache: &Executable.getAnnotatedExceptionTypes_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [AnnotatedTypeForward](), from: __return )
    }


    /// In declared protocol but not defined.. ///

    /// public default java.lang.annotation.Annotation[] java.lang.reflect.AnnotatedElement.getDeclaredAnnotationsByType(java.lang.Class)

    /// public abstract java.lang.annotation.Annotation[] java.lang.reflect.AnnotatedElement.getDeclaredAnnotations()

    /// public abstract java.lang.annotation.Annotation[] java.lang.reflect.AnnotatedElement.getAnnotations()

    /// public default boolean java.lang.reflect.AnnotatedElement.isAnnotationPresent(java.lang.Class)

    /// public default java.lang.annotation.Annotation java.lang.reflect.AnnotatedElement.getDeclaredAnnotation(java.lang.Class)

}

