
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:08 GMT 2016 ///

/// class java.lang.reflect.Array ///

open class Array: JavaObject {

    public convenience init?( casting object: JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.lang.reflect.Array", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ArrayJNIClass: jclass?

    /// private java.lang.reflect.Array()

    /// public static native java.lang.Object java.lang.reflect.Array.get(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var get_MethodID_1: jmethodID?

    open class func get( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "get", methodSig: "(Ljava/lang/Object;I)Ljava/lang/Object;", methodCache: &get_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }

    open class func get( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> JavaObject! {
        return try get( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native int java.lang.reflect.Array.getLength(java.lang.Object) throws java.lang.IllegalArgumentException

    private static var getLength_MethodID_2: jmethodID?

    open class func getLength( arg0: JavaObject? ) throws /* java.lang.IllegalArgumentException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getLength", methodSig: "(Ljava/lang/Object;)I", methodCache: &getLength_MethodID_2, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func getLength( _ _arg0: JavaObject? ) throws /* java.lang.IllegalArgumentException */ -> Int {
        return try getLength( arg0: _arg0 )
    }

    /// private static native java.lang.Object java.lang.reflect.Array.newArray(java.lang.Class,int) throws java.lang.NegativeArraySizeException

    /// public static native boolean java.lang.reflect.Array.getBoolean(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getBoolean_MethodID_3: jmethodID?

    open class func getBoolean( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getBoolean", methodSig: "(Ljava/lang/Object;I)Z", methodCache: &getBoolean_MethodID_3, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func getBoolean( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Bool {
        return try getBoolean( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native byte java.lang.reflect.Array.getByte(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getByte_MethodID_4: jmethodID?

    open class func getByte( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int8 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticByteMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getByte", methodSig: "(Ljava/lang/Object;I)B", methodCache: &getByte_MethodID_4, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Int8(), from: __return )
    }

    open class func getByte( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int8 {
        return try getByte( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native short java.lang.reflect.Array.getShort(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getShort_MethodID_5: jmethodID?

    open class func getShort( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int16 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticShortMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getShort", methodSig: "(Ljava/lang/Object;I)S", methodCache: &getShort_MethodID_5, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Int16(), from: __return )
    }

    open class func getShort( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int16 {
        return try getShort( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native char java.lang.reflect.Array.getChar(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getChar_MethodID_6: jmethodID?

    open class func getChar( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> UInt16 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticCharMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getChar", methodSig: "(Ljava/lang/Object;I)C", methodCache: &getChar_MethodID_6, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: UInt16(), from: __return )
    }

    open class func getChar( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> UInt16 {
        return try getChar( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native int java.lang.reflect.Array.getInt(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getInt_MethodID_7: jmethodID?

    open class func getInt( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getInt", methodSig: "(Ljava/lang/Object;I)I", methodCache: &getInt_MethodID_7, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func getInt( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int {
        return try getInt( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native long java.lang.reflect.Array.getLong(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getLong_MethodID_8: jmethodID?

    open class func getLong( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getLong", methodSig: "(Ljava/lang/Object;I)J", methodCache: &getLong_MethodID_8, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Int64(), from: __return )
    }

    open class func getLong( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Int64 {
        return try getLong( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native float java.lang.reflect.Array.getFloat(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getFloat_MethodID_9: jmethodID?

    open class func getFloat( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getFloat", methodSig: "(Ljava/lang/Object;I)F", methodCache: &getFloat_MethodID_9, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func getFloat( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Float {
        return try getFloat( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native double java.lang.reflect.Array.getDouble(java.lang.Object,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var getDouble_MethodID_10: jmethodID?

    open class func getDouble( arg0: JavaObject?, arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "getDouble", methodSig: "(Ljava/lang/Object;I)D", methodCache: &getDouble_MethodID_10, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func getDouble( _ _arg0: JavaObject?, _ _arg1: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ -> Double {
        return try getDouble( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.Object java.lang.reflect.Array.newInstance(java.lang.Class,int[]) throws java.lang.IllegalArgumentException,java.lang.NegativeArraySizeException

    private static var newInstance_MethodID_11: jmethodID?

    open class func newInstance( arg0: Class?, arg1: [Int32]? ) throws /* java.lang.IllegalArgumentException, java.lang.NegativeArraySizeException */ -> JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "newInstance", methodSig: "(Ljava/lang/Class;[I)Ljava/lang/Object;", methodCache: &newInstance_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }

    open class func newInstance( _ _arg0: Class?, _ _arg1: [Int32]? ) throws /* java.lang.IllegalArgumentException, java.lang.NegativeArraySizeException */ -> JavaObject! {
        return try newInstance( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.Object java.lang.reflect.Array.newInstance(java.lang.Class,int) throws java.lang.NegativeArraySizeException

    private static var newInstance_MethodID_12: jmethodID?

    open class func newInstance( arg0: Class?, arg1: Int ) throws /* java.lang.NegativeArraySizeException */ -> JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "newInstance", methodSig: "(Ljava/lang/Class;I)Ljava/lang/Object;", methodCache: &newInstance_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw NegativeArraySizeException( javaObject: throwable )
        }
        return __return != nil ? JavaObject( javaObject: __return ) : nil
    }

    open class func newInstance( _ _arg0: Class?, _ _arg1: Int ) throws /* java.lang.NegativeArraySizeException */ -> JavaObject! {
        return try newInstance( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native void java.lang.reflect.Array.set(java.lang.Object,int,java.lang.Object) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var set_MethodID_13: jmethodID?

    open class func set( arg0: JavaObject?, arg1: Int, arg2: JavaObject? ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "set", methodSig: "(Ljava/lang/Object;ILjava/lang/Object;)V", methodCache: &set_MethodID_13, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func set( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: JavaObject? ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try set( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setBoolean(java.lang.Object,int,boolean) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setBoolean_MethodID_14: jmethodID?

    open class func setBoolean( arg0: JavaObject?, arg1: Int, arg2: Bool ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setBoolean", methodSig: "(Ljava/lang/Object;IZ)V", methodCache: &setBoolean_MethodID_14, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setBoolean( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Bool ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setBoolean( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setByte(java.lang.Object,int,byte) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setByte_MethodID_15: jmethodID?

    open class func setByte( arg0: JavaObject?, arg1: Int, arg2: Int8 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setByte", methodSig: "(Ljava/lang/Object;IB)V", methodCache: &setByte_MethodID_15, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setByte( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Int8 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setByte( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setChar(java.lang.Object,int,char) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setChar_MethodID_16: jmethodID?

    open class func setChar( arg0: JavaObject?, arg1: Int, arg2: UInt16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setChar", methodSig: "(Ljava/lang/Object;IC)V", methodCache: &setChar_MethodID_16, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setChar( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: UInt16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setChar( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setShort(java.lang.Object,int,short) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setShort_MethodID_17: jmethodID?

    open class func setShort( arg0: JavaObject?, arg1: Int, arg2: Int16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setShort", methodSig: "(Ljava/lang/Object;IS)V", methodCache: &setShort_MethodID_17, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setShort( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Int16 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setShort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setInt(java.lang.Object,int,int) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setInt_MethodID_18: jmethodID?

    open class func setInt( arg0: JavaObject?, arg1: Int, arg2: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setInt", methodSig: "(Ljava/lang/Object;II)V", methodCache: &setInt_MethodID_18, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setInt( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Int ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setInt( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setLong(java.lang.Object,int,long) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setLong_MethodID_19: jmethodID?

    open class func setLong( arg0: JavaObject?, arg1: Int, arg2: Int64 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setLong", methodSig: "(Ljava/lang/Object;IJ)V", methodCache: &setLong_MethodID_19, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setLong( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Int64 ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setLong( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setFloat(java.lang.Object,int,float) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setFloat_MethodID_20: jmethodID?

    open class func setFloat( arg0: JavaObject?, arg1: Int, arg2: Float ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setFloat", methodSig: "(Ljava/lang/Object;IF)V", methodCache: &setFloat_MethodID_20, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setFloat( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Float ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setFloat( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static native void java.lang.reflect.Array.setDouble(java.lang.Object,int,double) throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException

    private static var setDouble_MethodID_21: jmethodID?

    open class func setDouble( arg0: JavaObject?, arg1: Int, arg2: Double ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/lang/reflect/Array", classCache: &ArrayJNIClass, methodName: "setDouble", methodSig: "(Ljava/lang/Object;ID)V", methodCache: &setDouble_MethodID_21, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw IllegalArgumentException( javaObject: throwable )
        }
    }

    open class func setDouble( _ _arg0: JavaObject?, _ _arg1: Int, _ _arg2: Double ) throws /* java.lang.IllegalArgumentException, java.lang.ArrayIndexOutOfBoundsException */ {
        try setDouble( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// private static native java.lang.Object java.lang.reflect.Array.multiNewArray(java.lang.Class,int[]) throws java.lang.IllegalArgumentException,java.lang.NegativeArraySizeException

}
