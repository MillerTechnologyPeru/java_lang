
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:08 GMT 2016 ///

/// class java.lang.StrictMath ///

open class StrictMath: JavaObject {

    public convenience init?( casting object: JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.lang.StrictMath", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var StrictMathJNIClass: jclass?

    /// public static final double java.lang.StrictMath.E

    private static var E_FieldID: jfieldID?

    open static var E: Double {
        get {
            let __value = JNIField.GetStaticDoubleField( fieldName: "E", fieldType: "D", fieldCache: &E_FieldID, className: "java/lang/StrictMath", classCache: &StrictMathJNIClass )
            return JNIType.decode( type: Double(), from: __value )
        }
    }

    /// public static final double java.lang.StrictMath.PI

    private static var PI_FieldID: jfieldID?

    open static var PI: Double {
        get {
            let __value = JNIField.GetStaticDoubleField( fieldName: "PI", fieldType: "D", fieldCache: &PI_FieldID, className: "java/lang/StrictMath", classCache: &StrictMathJNIClass )
            return JNIType.decode( type: Double(), from: __value )
        }
    }

    /// private static java.util.Random java.lang.StrictMath.randomNumberGenerator

    /// private static long java.lang.StrictMath.negativeZeroFloatBits

    /// private static long java.lang.StrictMath.negativeZeroDoubleBits

    /// static final boolean java.lang.StrictMath.$assertionsDisabled

    /// private java.lang.StrictMath()

    /// public static int java.lang.StrictMath.abs(int)

    private static var abs_MethodID_1: jmethodID?

    open class func abs( arg0: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(I)I", methodCache: &abs_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func abs( _ _arg0: Int ) -> Int {
        return abs( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.abs(double)

    private static var abs_MethodID_2: jmethodID?

    open class func abs( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(D)D", methodCache: &abs_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func abs( _ _arg0: Double ) -> Double {
        return abs( arg0: _arg0 )
    }

    /// public static float java.lang.StrictMath.abs(float)

    private static var abs_MethodID_3: jmethodID?

    open class func abs( arg0: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(F)F", methodCache: &abs_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func abs( _ _arg0: Float ) -> Float {
        return abs( arg0: _arg0 )
    }

    /// public static long java.lang.StrictMath.abs(long)

    private static var abs_MethodID_4: jmethodID?

    open class func abs( arg0: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "abs", methodSig: "(J)J", methodCache: &abs_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open class func abs( _ _arg0: Int64 ) -> Int64 {
        return abs( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.sin(double)

    private static var sin_MethodID_5: jmethodID?

    open class func sin( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sin", methodSig: "(D)D", methodCache: &sin_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func sin( _ _arg0: Double ) -> Double {
        return sin( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.cos(double)

    private static var cos_MethodID_6: jmethodID?

    open class func cos( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cos", methodSig: "(D)D", methodCache: &cos_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func cos( _ _arg0: Double ) -> Double {
        return cos( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.tan(double)

    private static var tan_MethodID_7: jmethodID?

    open class func tan( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "tan", methodSig: "(D)D", methodCache: &tan_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func tan( _ _arg0: Double ) -> Double {
        return tan( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.atan2(double,double)

    private static var atan2_MethodID_8: jmethodID?

    open class func atan2( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "atan2", methodSig: "(DD)D", methodCache: &atan2_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func atan2( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return atan2( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native double java.lang.StrictMath.sqrt(double)

    private static var sqrt_MethodID_9: jmethodID?

    open class func sqrt( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sqrt", methodSig: "(D)D", methodCache: &sqrt_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func sqrt( _ _arg0: Double ) -> Double {
        return sqrt( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.log(double)

    private static var log_MethodID_10: jmethodID?

    open class func log( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log", methodSig: "(D)D", methodCache: &log_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func log( _ _arg0: Double ) -> Double {
        return log( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.log10(double)

    private static var log10_MethodID_11: jmethodID?

    open class func log10( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log10", methodSig: "(D)D", methodCache: &log10_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func log10( _ _arg0: Double ) -> Double {
        return log10( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.pow(double,double)

    private static var pow_MethodID_12: jmethodID?

    open class func pow( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "pow", methodSig: "(DD)D", methodCache: &pow_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func pow( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return pow( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native double java.lang.StrictMath.exp(double)

    private static var exp_MethodID_13: jmethodID?

    open class func exp( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "exp", methodSig: "(D)D", methodCache: &exp_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func exp( _ _arg0: Double ) -> Double {
        return exp( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.min(double,double)

    private static var min_MethodID_14: jmethodID?

    open class func min( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(DD)D", methodCache: &min_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func min( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return min( arg0: _arg0, arg1: _arg1 )
    }

    /// public static float java.lang.StrictMath.min(float,float)

    private static var min_MethodID_15: jmethodID?

    open class func min( arg0: Float, arg1: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(FF)F", methodCache: &min_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func min( _ _arg0: Float, _ _arg1: Float ) -> Float {
        return min( arg0: _arg0, arg1: _arg1 )
    }

    /// public static long java.lang.StrictMath.min(long,long)

    private static var min_MethodID_16: jmethodID?

    open class func min( arg0: Int64, arg1: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(JJ)J", methodCache: &min_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open class func min( _ _arg0: Int64, _ _arg1: Int64 ) -> Int64 {
        return min( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.lang.StrictMath.min(int,int)

    private static var min_MethodID_17: jmethodID?

    open class func min( arg0: Int, arg1: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "min", methodSig: "(II)I", methodCache: &min_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func min( _ _arg0: Int, _ _arg1: Int ) -> Int {
        return min( arg0: _arg0, arg1: _arg1 )
    }

    /// public static long java.lang.StrictMath.max(long,long)

    private static var max_MethodID_18: jmethodID?

    open class func max( arg0: Int64, arg1: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(JJ)J", methodCache: &max_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open class func max( _ _arg0: Int64, _ _arg1: Int64 ) -> Int64 {
        return max( arg0: _arg0, arg1: _arg1 )
    }

    /// public static float java.lang.StrictMath.max(float,float)

    private static var max_MethodID_19: jmethodID?

    open class func max( arg0: Float, arg1: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(FF)F", methodCache: &max_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func max( _ _arg0: Float, _ _arg1: Float ) -> Float {
        return max( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.lang.StrictMath.max(int,int)

    private static var max_MethodID_20: jmethodID?

    open class func max( arg0: Int, arg1: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(II)I", methodCache: &max_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func max( _ _arg0: Int, _ _arg1: Int ) -> Int {
        return max( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.max(double,double)

    private static var max_MethodID_21: jmethodID?

    open class func max( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "max", methodSig: "(DD)D", methodCache: &max_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func max( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return max( arg0: _arg0, arg1: _arg1 )
    }

    /// public static float java.lang.StrictMath.scalb(float,int)

    private static var scalb_MethodID_22: jmethodID?

    open class func scalb( arg0: Float, arg1: Int ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "scalb", methodSig: "(FI)F", methodCache: &scalb_MethodID_22, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func scalb( _ _arg0: Float, _ _arg1: Int ) -> Float {
        return scalb( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.scalb(double,int)

    private static var scalb_MethodID_23: jmethodID?

    open class func scalb( arg0: Double, arg1: Int ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "scalb", methodSig: "(DI)D", methodCache: &scalb_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func scalb( _ _arg0: Double, _ _arg1: Int ) -> Double {
        return scalb( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.lang.StrictMath.getExponent(double)

    private static var getExponent_MethodID_24: jmethodID?

    open class func getExponent( arg0: Double ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "getExponent", methodSig: "(D)I", methodCache: &getExponent_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func getExponent( _ _arg0: Double ) -> Int {
        return getExponent( arg0: _arg0 )
    }

    /// public static int java.lang.StrictMath.getExponent(float)

    private static var getExponent_MethodID_25: jmethodID?

    open class func getExponent( arg0: Float ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "getExponent", methodSig: "(F)I", methodCache: &getExponent_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func getExponent( _ _arg0: Float ) -> Int {
        return getExponent( arg0: _arg0 )
    }

    /// public static float java.lang.StrictMath.signum(float)

    private static var signum_MethodID_26: jmethodID?

    open class func signum( arg0: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "signum", methodSig: "(F)F", methodCache: &signum_MethodID_26, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func signum( _ _arg0: Float ) -> Float {
        return signum( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.signum(double)

    private static var signum_MethodID_27: jmethodID?

    open class func signum( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "signum", methodSig: "(D)D", methodCache: &signum_MethodID_27, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func signum( _ _arg0: Double ) -> Double {
        return signum( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.asin(double)

    private static var asin_MethodID_28: jmethodID?

    open class func asin( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "asin", methodSig: "(D)D", methodCache: &asin_MethodID_28, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func asin( _ _arg0: Double ) -> Double {
        return asin( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.acos(double)

    private static var acos_MethodID_29: jmethodID?

    open class func acos( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "acos", methodSig: "(D)D", methodCache: &acos_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func acos( _ _arg0: Double ) -> Double {
        return acos( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.atan(double)

    private static var atan_MethodID_30: jmethodID?

    open class func atan( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "atan", methodSig: "(D)D", methodCache: &atan_MethodID_30, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func atan( _ _arg0: Double ) -> Double {
        return atan( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.toRadians(double)

    private static var toRadians_MethodID_31: jmethodID?

    open class func toRadians( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "toRadians", methodSig: "(D)D", methodCache: &toRadians_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func toRadians( _ _arg0: Double ) -> Double {
        return toRadians( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.toDegrees(double)

    private static var toDegrees_MethodID_32: jmethodID?

    open class func toDegrees( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "toDegrees", methodSig: "(D)D", methodCache: &toDegrees_MethodID_32, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func toDegrees( _ _arg0: Double ) -> Double {
        return toDegrees( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.cbrt(double)

    private static var cbrt_MethodID_33: jmethodID?

    open class func cbrt( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cbrt", methodSig: "(D)D", methodCache: &cbrt_MethodID_33, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func cbrt( _ _arg0: Double ) -> Double {
        return cbrt( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.IEEEremainder(double,double)

    private static var IEEEremainder_MethodID_34: jmethodID?

    open class func IEEEremainder( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "IEEEremainder", methodSig: "(DD)D", methodCache: &IEEEremainder_MethodID_34, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func IEEEremainder( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return IEEEremainder( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.ceil(double)

    private static var ceil_MethodID_35: jmethodID?

    open class func ceil( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ceil", methodSig: "(D)D", methodCache: &ceil_MethodID_35, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func ceil( _ _arg0: Double ) -> Double {
        return ceil( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.floor(double)

    private static var floor_MethodID_36: jmethodID?

    open class func floor( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "floor", methodSig: "(D)D", methodCache: &floor_MethodID_36, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func floor( _ _arg0: Double ) -> Double {
        return floor( arg0: _arg0 )
    }

    /// public static double java.lang.StrictMath.rint(double)

    private static var rint_MethodID_37: jmethodID?

    open class func rint( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "rint", methodSig: "(D)D", methodCache: &rint_MethodID_37, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func rint( _ _arg0: Double ) -> Double {
        return rint( arg0: _arg0 )
    }

    /// public static int java.lang.StrictMath.round(float)

    private static var round_MethodID_38: jmethodID?

    open class func round( arg0: Float ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "round", methodSig: "(F)I", methodCache: &round_MethodID_38, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func round( _ _arg0: Float ) -> Int {
        return round( arg0: _arg0 )
    }

    /// public static long java.lang.StrictMath.round(double)

    private static var round_MethodID_39: jmethodID?

    open class func round( arg0: Double ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticLongMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "round", methodSig: "(D)J", methodCache: &round_MethodID_39, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open class func round( _ _arg0: Double ) -> Int64 {
        return round( arg0: _arg0 )
    }

    /// private static synchronized void java.lang.StrictMath.initRNG()

    /// public static double java.lang.StrictMath.random()

    private static var random_MethodID_40: jmethodID?

    open class func random() -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "random", methodSig: "()D", methodCache: &random_MethodID_40, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }


    /// public static double java.lang.StrictMath.ulp(double)

    private static var ulp_MethodID_41: jmethodID?

    open class func ulp( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ulp", methodSig: "(D)D", methodCache: &ulp_MethodID_41, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func ulp( _ _arg0: Double ) -> Double {
        return ulp( arg0: _arg0 )
    }

    /// public static float java.lang.StrictMath.ulp(float)

    private static var ulp_MethodID_42: jmethodID?

    open class func ulp( arg0: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "ulp", methodSig: "(F)F", methodCache: &ulp_MethodID_42, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func ulp( _ _arg0: Float ) -> Float {
        return ulp( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.sinh(double)

    private static var sinh_MethodID_43: jmethodID?

    open class func sinh( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "sinh", methodSig: "(D)D", methodCache: &sinh_MethodID_43, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func sinh( _ _arg0: Double ) -> Double {
        return sinh( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.cosh(double)

    private static var cosh_MethodID_44: jmethodID?

    open class func cosh( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "cosh", methodSig: "(D)D", methodCache: &cosh_MethodID_44, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func cosh( _ _arg0: Double ) -> Double {
        return cosh( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.tanh(double)

    private static var tanh_MethodID_45: jmethodID?

    open class func tanh( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "tanh", methodSig: "(D)D", methodCache: &tanh_MethodID_45, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func tanh( _ _arg0: Double ) -> Double {
        return tanh( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.hypot(double,double)

    private static var hypot_MethodID_46: jmethodID?

    open class func hypot( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "hypot", methodSig: "(DD)D", methodCache: &hypot_MethodID_46, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func hypot( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return hypot( arg0: _arg0, arg1: _arg1 )
    }

    /// public static native double java.lang.StrictMath.expm1(double)

    private static var expm1_MethodID_47: jmethodID?

    open class func expm1( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "expm1", methodSig: "(D)D", methodCache: &expm1_MethodID_47, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func expm1( _ _arg0: Double ) -> Double {
        return expm1( arg0: _arg0 )
    }

    /// public static native double java.lang.StrictMath.log1p(double)

    private static var log1p_MethodID_48: jmethodID?

    open class func log1p( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "log1p", methodSig: "(D)D", methodCache: &log1p_MethodID_48, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func log1p( _ _arg0: Double ) -> Double {
        return log1p( arg0: _arg0 )
    }

    /// public static float java.lang.StrictMath.copySign(float,float)

    private static var copySign_MethodID_49: jmethodID?

    open class func copySign( arg0: Float, arg1: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "copySign", methodSig: "(FF)F", methodCache: &copySign_MethodID_49, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func copySign( _ _arg0: Float, _ _arg1: Float ) -> Float {
        return copySign( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.copySign(double,double)

    private static var copySign_MethodID_50: jmethodID?

    open class func copySign( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "copySign", methodSig: "(DD)D", methodCache: &copySign_MethodID_50, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func copySign( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return copySign( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.nextAfter(double,double)

    private static var nextAfter_MethodID_51: jmethodID?

    open class func nextAfter( arg0: Double, arg1: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextAfter", methodSig: "(DD)D", methodCache: &nextAfter_MethodID_51, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func nextAfter( _ _arg0: Double, _ _arg1: Double ) -> Double {
        return nextAfter( arg0: _arg0, arg1: _arg1 )
    }

    /// public static float java.lang.StrictMath.nextAfter(float,double)

    private static var nextAfter_MethodID_52: jmethodID?

    open class func nextAfter( arg0: Float, arg1: Double ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextAfter", methodSig: "(FD)F", methodCache: &nextAfter_MethodID_52, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func nextAfter( _ _arg0: Float, _ _arg1: Double ) -> Float {
        return nextAfter( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double java.lang.StrictMath.nextUp(double)

    private static var nextUp_MethodID_53: jmethodID?

    open class func nextUp( arg0: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticDoubleMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextUp", methodSig: "(D)D", methodCache: &nextUp_MethodID_53, args: &__args, locals: &__locals )
        return JNIType.decode( type: Double(), from: __return )
    }

    open class func nextUp( _ _arg0: Double ) -> Double {
        return nextUp( arg0: _arg0 )
    }

    /// public static float java.lang.StrictMath.nextUp(float)

    private static var nextUp_MethodID_54: jmethodID?

    open class func nextUp( arg0: Float ) -> Float {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticFloatMethod( className: "java/lang/StrictMath", classCache: &StrictMathJNIClass, methodName: "nextUp", methodSig: "(F)F", methodCache: &nextUp_MethodID_54, args: &__args, locals: &__locals )
        return JNIType.decode( type: Float(), from: __return )
    }

    open class func nextUp( _ _arg0: Float ) -> Float {
        return nextUp( arg0: _arg0 )
    }

    /// private static double java.lang.StrictMath.floorOrCeil(double,double,double,double)

}
