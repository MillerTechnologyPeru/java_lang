
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.lang.management.ThreadInfo ///

open class ThreadInfo: java_swift.JavaObject {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ThreadInfoJNIClass: jclass?

    /// private java.lang.String java.lang.management.ThreadInfo.threadName

    /// private long java.lang.management.ThreadInfo.threadId

    /// private long java.lang.management.ThreadInfo.blockedTime

    /// private long java.lang.management.ThreadInfo.blockedCount

    /// private long java.lang.management.ThreadInfo.waitedTime

    /// private long java.lang.management.ThreadInfo.waitedCount

    /// private java.lang.management.LockInfo java.lang.management.ThreadInfo.lock

    /// private java.lang.String java.lang.management.ThreadInfo.lockName

    /// private long java.lang.management.ThreadInfo.lockOwnerId

    /// private java.lang.String java.lang.management.ThreadInfo.lockOwnerName

    /// private boolean java.lang.management.ThreadInfo.inNative

    /// private boolean java.lang.management.ThreadInfo.suspended

    /// private java.lang.Thread$State java.lang.management.ThreadInfo.threadState

    /// private java.lang.StackTraceElement[] java.lang.management.ThreadInfo.stackTrace

    /// private java.lang.management.MonitorInfo[] java.lang.management.ThreadInfo.lockedMonitors

    /// private java.lang.management.LockInfo[] java.lang.management.ThreadInfo.lockedSynchronizers

    /// private static java.lang.management.MonitorInfo[] java.lang.management.ThreadInfo.EMPTY_MONITORS

    /// private static java.lang.management.LockInfo[] java.lang.management.ThreadInfo.EMPTY_SYNCS

    /// private static final int java.lang.management.ThreadInfo.MAX_FRAMES

    /// private static final java.lang.StackTraceElement[] java.lang.management.ThreadInfo.NO_STACK_TRACE

    /// static final boolean java.lang.management.ThreadInfo.$assertionsDisabled

    /// private java.lang.management.ThreadInfo(javax.management.openmbean.CompositeData)

    /// private java.lang.management.ThreadInfo(java.lang.Thread,int,java.lang.Object,java.lang.Thread,long,long,long,long,java.lang.StackTraceElement[],java.lang.Object[],int[],java.lang.Object[])

    /// private java.lang.management.ThreadInfo(java.lang.Thread,int,java.lang.Object,java.lang.Thread,long,long,long,long,java.lang.StackTraceElement[])

    /// public java.lang.String java.lang.management.ThreadInfo.toString()

    /// public java.lang.StackTraceElement[] java.lang.management.ThreadInfo.getStackTrace()

    private static var getStackTrace_MethodID_1: jmethodID?

    open func getStackTrace() -> [StackTraceElement]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getStackTrace", methodSig: "()[Ljava/lang/StackTraceElement;", methodCache: &ThreadInfo.getStackTrace_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [StackTraceElement](), from: __return )
    }


    /// private void java.lang.management.ThreadInfo.initialize(java.lang.Thread,int,java.lang.Object,java.lang.Thread,long,long,long,long,java.lang.StackTraceElement[],java.lang.management.MonitorInfo[],java.lang.management.LockInfo[])

    /// public static java.lang.management.ThreadInfo java.lang.management.ThreadInfo.from(javax.management.openmbean.CompositeData)

    private static var from_MethodID_2: jmethodID?

    open class func from( cd: /* javax.management.openmbean.CompositeData */ UnclassedProtocol? ) -> ThreadInfo! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: cd, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/lang/management/ThreadInfo", classCache: &ThreadInfoJNIClass, methodName: "from", methodSig: "(Ljavax/management/openmbean/CompositeData;)Ljava/lang/management/ThreadInfo;", methodCache: &from_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ThreadInfo( javaObject: __return ) : nil
    }

    open class func from( _ _cd: /* javax.management.openmbean.CompositeData */ UnclassedProtocol? ) -> ThreadInfo! {
        return from( cd: _cd )
    }

    /// public long java.lang.management.ThreadInfo.getThreadId()

    private static var getThreadId_MethodID_3: jmethodID?

    open func getThreadId() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getThreadId", methodSig: "()J", methodCache: &ThreadInfo.getThreadId_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public java.lang.String java.lang.management.ThreadInfo.getThreadName()

    private static var getThreadName_MethodID_4: jmethodID?

    open func getThreadName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadName", methodSig: "()Ljava/lang/String;", methodCache: &ThreadInfo.getThreadName_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: String(), from: __return )
    }


    /// public java.lang.Thread$State java.lang.management.ThreadInfo.getThreadState()

    private static var getThreadState_MethodID_5: jmethodID?

    open func getThreadState() -> Thread_State! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getThreadState", methodSig: "()Ljava/lang/Thread$State;", methodCache: &ThreadInfo.getThreadState_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Thread_State( javaObject: __return ) : nil
    }


    /// public long java.lang.management.ThreadInfo.getBlockedTime()

    private static var getBlockedTime_MethodID_6: jmethodID?

    open func getBlockedTime() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getBlockedTime", methodSig: "()J", methodCache: &ThreadInfo.getBlockedTime_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public long java.lang.management.ThreadInfo.getBlockedCount()

    private static var getBlockedCount_MethodID_7: jmethodID?

    open func getBlockedCount() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getBlockedCount", methodSig: "()J", methodCache: &ThreadInfo.getBlockedCount_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public long java.lang.management.ThreadInfo.getWaitedTime()

    private static var getWaitedTime_MethodID_8: jmethodID?

    open func getWaitedTime() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getWaitedTime", methodSig: "()J", methodCache: &ThreadInfo.getWaitedTime_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public long java.lang.management.ThreadInfo.getWaitedCount()

    private static var getWaitedCount_MethodID_9: jmethodID?

    open func getWaitedCount() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getWaitedCount", methodSig: "()J", methodCache: &ThreadInfo.getWaitedCount_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public java.lang.String java.lang.management.ThreadInfo.getLockName()

    private static var getLockName_MethodID_10: jmethodID?

    open func getLockName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLockName", methodSig: "()Ljava/lang/String;", methodCache: &ThreadInfo.getLockName_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: String(), from: __return )
    }


    /// public long java.lang.management.ThreadInfo.getLockOwnerId()

    private static var getLockOwnerId_MethodID_11: jmethodID?

    open func getLockOwnerId() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getLockOwnerId", methodSig: "()J", methodCache: &ThreadInfo.getLockOwnerId_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }


    /// public java.lang.String java.lang.management.ThreadInfo.getLockOwnerName()

    private static var getLockOwnerName_MethodID_12: jmethodID?

    open func getLockOwnerName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLockOwnerName", methodSig: "()Ljava/lang/String;", methodCache: &ThreadInfo.getLockOwnerName_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: String(), from: __return )
    }


    /// public boolean java.lang.management.ThreadInfo.isSuspended()

    private static var isSuspended_MethodID_13: jmethodID?

    open func isSuspended() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isSuspended", methodSig: "()Z", methodCache: &ThreadInfo.isSuspended_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public boolean java.lang.management.ThreadInfo.isInNative()

    private static var isInNative_MethodID_14: jmethodID?

    open func isInNative() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isInNative", methodSig: "()Z", methodCache: &ThreadInfo.isInNative_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Bool(), from: __return )
    }


    /// public java.lang.management.MonitorInfo[] java.lang.management.ThreadInfo.getLockedMonitors()

    private static var getLockedMonitors_MethodID_15: jmethodID?

    open func getLockedMonitors() -> [MonitorInfo]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLockedMonitors", methodSig: "()[Ljava/lang/management/MonitorInfo;", methodCache: &ThreadInfo.getLockedMonitors_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [MonitorInfo](), from: __return )
    }


    /// public java.lang.management.LockInfo[] java.lang.management.ThreadInfo.getLockedSynchronizers()

    private static var getLockedSynchronizers_MethodID_16: jmethodID?

    open func getLockedSynchronizers() -> [LockInfo]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLockedSynchronizers", methodSig: "()[Ljava/lang/management/LockInfo;", methodCache: &ThreadInfo.getLockedSynchronizers_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [LockInfo](), from: __return )
    }


    /// public java.lang.management.LockInfo java.lang.management.ThreadInfo.getLockInfo()

    private static var getLockInfo_MethodID_17: jmethodID?

    open func getLockInfo() -> LockInfo! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLockInfo", methodSig: "()Ljava/lang/management/LockInfo;", methodCache: &ThreadInfo.getLockInfo_MethodID_17, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? LockInfo( javaObject: __return ) : nil
    }


}

