
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:03 GMT 2016 ///

/// interface java.lang.instrument.Instrumentation ///

public protocol Instrumentation: JavaProtocol {

    /// public abstract void java.lang.instrument.Instrumentation.addTransformer(java.lang.instrument.ClassFileTransformer,boolean)

    func addTransformer( arg0: ClassFileTransformer?, arg1: Bool )
    func addTransformer( _ _arg0: ClassFileTransformer?, _ _arg1: Bool )

    /// public abstract void java.lang.instrument.Instrumentation.addTransformer(java.lang.instrument.ClassFileTransformer)

    func addTransformer( arg0: ClassFileTransformer? )
    func addTransformer( _ _arg0: ClassFileTransformer? )

    /// public abstract boolean java.lang.instrument.Instrumentation.removeTransformer(java.lang.instrument.ClassFileTransformer)

    func removeTransformer( arg0: ClassFileTransformer? ) -> Bool
    func removeTransformer( _ _arg0: ClassFileTransformer? ) -> Bool

    /// public abstract boolean java.lang.instrument.Instrumentation.isRetransformClassesSupported()

    func isRetransformClassesSupported() -> Bool

    /// public abstract void java.lang.instrument.Instrumentation.retransformClasses(java.lang.Class[]) throws java.lang.instrument.UnmodifiableClassException

    func retransformClasses( arg0: [Class]? ) throws /* java.lang.instrument.UnmodifiableClassException */
    func retransformClasses( _ _arg0: [Class]? ) throws /* java.lang.instrument.UnmodifiableClassException */

    /// public abstract boolean java.lang.instrument.Instrumentation.isRedefineClassesSupported()

    func isRedefineClassesSupported() -> Bool

    /// public abstract void java.lang.instrument.Instrumentation.redefineClasses(java.lang.instrument.ClassDefinition[]) throws java.lang.ClassNotFoundException,java.lang.instrument.UnmodifiableClassException

    func redefineClasses( arg0: [ClassDefinition]? ) throws /* java.lang.ClassNotFoundException, java.lang.instrument.UnmodifiableClassException */
    func redefineClasses( _ _arg0: [ClassDefinition]? ) throws /* java.lang.ClassNotFoundException, java.lang.instrument.UnmodifiableClassException */

    /// public abstract boolean java.lang.instrument.Instrumentation.isModifiableClass(java.lang.Class)

    func isModifiableClass( arg0: Class? ) -> Bool
    func isModifiableClass( _ _arg0: Class? ) -> Bool

    /// public abstract java.lang.Class[] java.lang.instrument.Instrumentation.getAllLoadedClasses()

    func getAllLoadedClasses() -> [Class]!

    /// public abstract java.lang.Class[] java.lang.instrument.Instrumentation.getInitiatedClasses(java.lang.ClassLoader)

    func getInitiatedClasses( arg0: ClassLoader? ) -> [Class]!
    func getInitiatedClasses( _ _arg0: ClassLoader? ) -> [Class]!

    /// public abstract long java.lang.instrument.Instrumentation.getObjectSize(java.lang.Object)

    func getObjectSize( arg0: JavaObject? ) -> Int64
    func getObjectSize( _ _arg0: JavaObject? ) -> Int64

    /// public abstract void java.lang.instrument.Instrumentation.appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)

    func appendToBootstrapClassLoaderSearch( arg0: /* java.util.jar.JarFile */ UnclassedObject? )
    func appendToBootstrapClassLoaderSearch( _ _arg0: /* java.util.jar.JarFile */ UnclassedObject? )

    /// public abstract void java.lang.instrument.Instrumentation.appendToSystemClassLoaderSearch(java.util.jar.JarFile)

    func appendToSystemClassLoaderSearch( arg0: /* java.util.jar.JarFile */ UnclassedObject? )
    func appendToSystemClassLoaderSearch( _ _arg0: /* java.util.jar.JarFile */ UnclassedObject? )

    /// public abstract boolean java.lang.instrument.Instrumentation.isNativeMethodPrefixSupported()

    func isNativeMethodPrefixSupported() -> Bool

    /// public abstract void java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)

    func setNativeMethodPrefix( arg0: ClassFileTransformer?, arg1: String? )
    func setNativeMethodPrefix( _ _arg0: ClassFileTransformer?, _ _arg1: String? )

}

open class InstrumentationForward: JNIObjectForward, Instrumentation {

    private static var InstrumentationJNIClass: jclass?

    /// public abstract void java.lang.instrument.Instrumentation.addTransformer(java.lang.instrument.ClassFileTransformer,boolean)

    private static var addTransformer_MethodID_16: jmethodID?

    open func addTransformer( arg0: ClassFileTransformer?, arg1: Bool ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addTransformer", methodSig: "(Ljava/lang/instrument/ClassFileTransformer;Z)V", methodCache: &InstrumentationForward.addTransformer_MethodID_16, args: &__args, locals: &__locals )
    }

    open func addTransformer( _ _arg0: ClassFileTransformer?, _ _arg1: Bool ) {
        addTransformer( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract void java.lang.instrument.Instrumentation.addTransformer(java.lang.instrument.ClassFileTransformer)

    private static var addTransformer_MethodID_17: jmethodID?

    open func addTransformer( arg0: ClassFileTransformer? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addTransformer", methodSig: "(Ljava/lang/instrument/ClassFileTransformer;)V", methodCache: &InstrumentationForward.addTransformer_MethodID_17, args: &__args, locals: &__locals )
    }

    open func addTransformer( _ _arg0: ClassFileTransformer? ) {
        addTransformer( arg0: _arg0 )
    }

    /// public abstract boolean java.lang.instrument.Instrumentation.removeTransformer(java.lang.instrument.ClassFileTransformer)

    private static var removeTransformer_MethodID_18: jmethodID?

    open func removeTransformer( arg0: ClassFileTransformer? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "removeTransformer", methodSig: "(Ljava/lang/instrument/ClassFileTransformer;)Z", methodCache: &InstrumentationForward.removeTransformer_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func removeTransformer( _ _arg0: ClassFileTransformer? ) -> Bool {
        return removeTransformer( arg0: _arg0 )
    }

    /// public abstract boolean java.lang.instrument.Instrumentation.isRetransformClassesSupported()

    private static var isRetransformClassesSupported_MethodID_19: jmethodID?

    open func isRetransformClassesSupported() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isRetransformClassesSupported", methodSig: "()Z", methodCache: &InstrumentationForward.isRetransformClassesSupported_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract void java.lang.instrument.Instrumentation.retransformClasses(java.lang.Class[]) throws java.lang.instrument.UnmodifiableClassException

    private static var retransformClasses_MethodID_20: jmethodID?

    open func retransformClasses( arg0: [Class]? ) throws /* java.lang.instrument.UnmodifiableClassException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "retransformClasses", methodSig: "([Ljava/lang/Class;)V", methodCache: &InstrumentationForward.retransformClasses_MethodID_20, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw UnmodifiableClassException( javaObject: throwable )
        }
    }

    open func retransformClasses( _ _arg0: [Class]? ) throws /* java.lang.instrument.UnmodifiableClassException */ {
        try retransformClasses( arg0: _arg0 )
    }

    /// public abstract boolean java.lang.instrument.Instrumentation.isRedefineClassesSupported()

    private static var isRedefineClassesSupported_MethodID_21: jmethodID?

    open func isRedefineClassesSupported() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isRedefineClassesSupported", methodSig: "()Z", methodCache: &InstrumentationForward.isRedefineClassesSupported_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract void java.lang.instrument.Instrumentation.redefineClasses(java.lang.instrument.ClassDefinition[]) throws java.lang.ClassNotFoundException,java.lang.instrument.UnmodifiableClassException

    private static var redefineClasses_MethodID_22: jmethodID?

    open func redefineClasses( arg0: [ClassDefinition]? ) throws /* java.lang.ClassNotFoundException, java.lang.instrument.UnmodifiableClassException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "redefineClasses", methodSig: "([Ljava/lang/instrument/ClassDefinition;)V", methodCache: &InstrumentationForward.redefineClasses_MethodID_22, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw ClassNotFoundException( javaObject: throwable )
        }
    }

    open func redefineClasses( _ _arg0: [ClassDefinition]? ) throws /* java.lang.ClassNotFoundException, java.lang.instrument.UnmodifiableClassException */ {
        try redefineClasses( arg0: _arg0 )
    }

    /// public abstract boolean java.lang.instrument.Instrumentation.isModifiableClass(java.lang.Class)

    private static var isModifiableClass_MethodID_23: jmethodID?

    open func isModifiableClass( arg0: Class? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isModifiableClass", methodSig: "(Ljava/lang/Class;)Z", methodCache: &InstrumentationForward.isModifiableClass_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isModifiableClass( _ _arg0: Class? ) -> Bool {
        return isModifiableClass( arg0: _arg0 )
    }

    /// public abstract java.lang.Class[] java.lang.instrument.Instrumentation.getAllLoadedClasses()

    private static var getAllLoadedClasses_MethodID_24: jmethodID?

    open func getAllLoadedClasses() -> [Class]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getAllLoadedClasses", methodSig: "()[Ljava/lang/Class;", methodCache: &InstrumentationForward.getAllLoadedClasses_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Class](), from: __return )
    }


    /// public abstract java.lang.Class[] java.lang.instrument.Instrumentation.getInitiatedClasses(java.lang.ClassLoader)

    private static var getInitiatedClasses_MethodID_25: jmethodID?

    open func getInitiatedClasses( arg0: ClassLoader? ) -> [Class]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getInitiatedClasses", methodSig: "(Ljava/lang/ClassLoader;)[Ljava/lang/Class;", methodCache: &InstrumentationForward.getInitiatedClasses_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Class](), from: __return )
    }

    open func getInitiatedClasses( _ _arg0: ClassLoader? ) -> [Class]! {
        return getInitiatedClasses( arg0: _arg0 )
    }

    /// public abstract long java.lang.instrument.Instrumentation.getObjectSize(java.lang.Object)

    private static var getObjectSize_MethodID_26: jmethodID?

    open func getObjectSize( arg0: JavaObject? ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getObjectSize", methodSig: "(Ljava/lang/Object;)J", methodCache: &InstrumentationForward.getObjectSize_MethodID_26, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open func getObjectSize( _ _arg0: JavaObject? ) -> Int64 {
        return getObjectSize( arg0: _arg0 )
    }

    /// public abstract void java.lang.instrument.Instrumentation.appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)

    private static var appendToBootstrapClassLoaderSearch_MethodID_27: jmethodID?

    open func appendToBootstrapClassLoaderSearch( arg0: /* java.util.jar.JarFile */ UnclassedObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "appendToBootstrapClassLoaderSearch", methodSig: "(Ljava/util/jar/JarFile;)V", methodCache: &InstrumentationForward.appendToBootstrapClassLoaderSearch_MethodID_27, args: &__args, locals: &__locals )
    }

    open func appendToBootstrapClassLoaderSearch( _ _arg0: /* java.util.jar.JarFile */ UnclassedObject? ) {
        appendToBootstrapClassLoaderSearch( arg0: _arg0 )
    }

    /// public abstract void java.lang.instrument.Instrumentation.appendToSystemClassLoaderSearch(java.util.jar.JarFile)

    private static var appendToSystemClassLoaderSearch_MethodID_28: jmethodID?

    open func appendToSystemClassLoaderSearch( arg0: /* java.util.jar.JarFile */ UnclassedObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "appendToSystemClassLoaderSearch", methodSig: "(Ljava/util/jar/JarFile;)V", methodCache: &InstrumentationForward.appendToSystemClassLoaderSearch_MethodID_28, args: &__args, locals: &__locals )
    }

    open func appendToSystemClassLoaderSearch( _ _arg0: /* java.util.jar.JarFile */ UnclassedObject? ) {
        appendToSystemClassLoaderSearch( arg0: _arg0 )
    }

    /// public abstract boolean java.lang.instrument.Instrumentation.isNativeMethodPrefixSupported()

    private static var isNativeMethodPrefixSupported_MethodID_29: jmethodID?

    open func isNativeMethodPrefixSupported() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isNativeMethodPrefixSupported", methodSig: "()Z", methodCache: &InstrumentationForward.isNativeMethodPrefixSupported_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public abstract void java.lang.instrument.Instrumentation.setNativeMethodPrefix(java.lang.instrument.ClassFileTransformer,java.lang.String)

    private static var setNativeMethodPrefix_MethodID_30: jmethodID?

    open func setNativeMethodPrefix( arg0: ClassFileTransformer?, arg1: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setNativeMethodPrefix", methodSig: "(Ljava/lang/instrument/ClassFileTransformer;Ljava/lang/String;)V", methodCache: &InstrumentationForward.setNativeMethodPrefix_MethodID_30, args: &__args, locals: &__locals )
    }

    open func setNativeMethodPrefix( _ _arg0: ClassFileTransformer?, _ _arg1: String? ) {
        setNativeMethodPrefix( arg0: _arg0, arg1: _arg1 )
    }

}


